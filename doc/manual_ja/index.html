<html>
  <head>
    <style type="text/css">
      <!--
	  body {
	  font-family: "メイリオ", Meiryo;
	  margin: 20px;
	  padding: 20px;
	  color: #404040;
	  }

	  h2 {
	  margin-top: 40px;
	  padding-top: 20px;
	  border-top: 4px dotted #404040;
	  }

	  ul { margin: 10px; }
	  ol { margin: 10px; }
	  
	  li { margin: 10px; }

	  a {
	  color: #ff8c00;
	  text-decoration: none;
	  }
	  
	  a:hover { text-decoration: underline; }

	  .indent { padding-left: 20px; }

	  .monospace { font-family: "Andale Mono", consolas; }

	  .code {
	  margin-left: 5px;
	  margin-right: 5px;
	  padding: 2px;
	  font-family: "Andale Mono", consolas;
	  Background-color: #f0f0f0;
	  border: thin solid #808080;
	  }

	  .equation { padding: 10px 20px; }

	  div.code {
	  margin-right: 20%;
	  margin: 10px;
	  }
	  
	-->
    </style>
    <script type="text/javascript">
      function setTexImage(img_id, tex) {
      var img = document.getElementById(img_id);
      var url = "http://chart.apis.google.com/chart?cht=tx&chl=" + encodeURIComponent(tex);
      /* var url = "http://formula.s21g.com/?" + encodeURIComponent(tex) + ".png"; */
      img.alt = tex;
      img.src = url;
      }
    </script>
    <title>Phillip</title>
  </head>
  <body>
    <h1>Phillip</h1>

    <h2>Contents<a name="Contents">^</a></h2>
    <ol type="1">
      <li><a href="#WhatsPhillip">What's phillip?</a></li>
      <li><a href="#Algorithm">Algorithm</a></li>
      <li><a href="#HowToInstall">How to install</a></li>
      <li><a href="#Usage">Usage</a></li>
      <li><a href="#Options">Options</a></li>
      <li><a href="#FileFormat">File format</a></li>
      <li><a href="#Components">Components</a></li>
      <li><a href="#Contact">Contact</a></li>
    </ol>
    
    <h2>What's Phillip?<a href="#Contents" name="WhatsPhillip">^</a></h2>
    一階述語論理に基づいた論理推論を用いて談話処理を行うための統合フレームワークです．<br>
    各操作をコンポーネントとして管理することで高いカスタマイズ性を実現しています．

    <h3>Download</h3>
    <a href="http://github.com/kazeto/phillip">github</a> からダウンロードが可能です．

    
    <h2>Algorithm<a href="#Contents" name="Algorithm">^</a></h2>
    Phillipは入力として一階述語論理リテラル集合 O，背景知識として公理集合 B，仮説の評価関数 E を受け取り，
    そこから導かれる仮説の候補の中で最も評価関数の値が大きいものを解仮説として出力します．<br>
    正式には以下のように記述されます．
    
    <div class="equation">
      <img id="algorithm-0" alt="algorithm-0"><br>
      <img id="algorithm-1" alt="algorithm-1">
    </div>
    
    解仮説の導出は以下の様なプロセスで行われます．
    <ol type="1">
      <li>
	仮説の候補 <img id="algorithm-2" alt="algorithm-2"> を列挙します．<br>
	これらの候補を本マニュアルでは<b>潜在仮説集合</b>（Latent Hypotheses Set, LHS）と表記しています．<br>
	Phillip においてこの処理はコンポーネント群 <a href="#Components_LHSEnumerator">LHS-Enumerator</a> として実装されています．
      </li>
      <li>
	潜在仮説集合および，その各要素に対する評価関数の値を，整数線形計画問題へ変換します．<br>
	Phillip においてこの処理はコンポーネント群 <a href="#Components_ILPConverter">ILP-Converter</a> として実装されています．
      </li>
      <li>
	外部のILPソルバーを用いて，上の手順で生成された整数線形計画問題に対する解を導出します．<br>
	Phillip においてこの処理はコンポーネント群 <a href="#Components_ILPSolver">ILP-Solver</a> として実装されています．
      </li>
    </ol>
    
    <script>
      setTexImage("algorithm-0", "Given.\\hspace{10px} O,\\ B,\\ E");
      setTexImage("algorithm-1", "Return.\\hspace{10px}{arg\\ max}_{\\{H|H \\cap B \\supset O\\}}E(H)");
      setTexImage("algorithm-2", "\\{H|H \\cap B \\supset O\\}");
    </script>

    
    <h2>How to install<a href="#Contents" name="HowToInstall">^</a></h2>
    <h3>Windows</h3>
    <ol type="1">
      <li>
	Phillip パッケージをダウンロードし，任意の場所に配置します．
      </li>
      <li>
	使用したいILPソルバーをインストールします．<br>
	現在は LP-Solve 5.5, Gurobi 5.6 に対応しています．
	Phillip は Win32 コンソールアプリケーションとしてビルドされるため，各ソルバーもそれに対応したものをインストールしてください．
      </li>
      <li>
	ソリューションファイル <span class="monospace">vs/phillip.sln</span> をVisualStudioで開き，プロジェクトのプロパティ設定を使用するソルバーに応じて適宜変更します．<br>
	以下にソルバーごとの設定箇所を記述します．
	<ul type="circle">
	  <li>
	    <b>LP-Solve</b><br>
	    「追加のインクルードディレクトリ」「追加のライブラリディレクトリ」にそれぞれ LP-Solve をインストールしたディレクトリを追加．<br>
	    「追加の依存ファイル」に <span class="monospace">liblpsolve55.lib</span>
	    または <span class="monospace">liblpsolve55d.lib</span> を追加．<br>
	    （デバッグビルドが <span class="monospace">liblpsolve55d.lib</span>，
	    リリースビルドが <span class="monospace">liblpsolve55.lib</span> です）
	  </li>
	  <li>
	    <b>Gurobi</b><br>
	    Under construction...
	  </li>
	</ul>
      </li>
      <li>
	VisualStudio を用いてビルドします．
      </li>
    </ol>
    <h3>Unix</h3>
    <ol type="1">
      <li>
	Phillip パッケージをダウンロードし，任意の場所に展開します．<br>
	環境に git をインストール済みであれば
	<div class="code">
	  $ git clone https://github.com/kazeto/phillip.git
	</div>
	とすることで簡単にダウンロードできます．
      </li>
      <li>
	使用したいILPソルバーをインストールし，必要な環境変数を設定します．<br>
	現在は LP-Solve 5.5, Gurobi 5.6 に対応しています．<br>
	以下にソルバーごとの設定内容を記述します．
	<ul type="circle">
	  <li>
	    <b>LP-Solve</b><br>
	    LP-Solve のヘッダディレクトリ（<span class="monospace">lp_lib.h</span> を含むディレクトリです）のパスを
	    環境変数 <span class="code">CPLUS_INCLUDE_PATH</span> へ設定してください．<br>
	    LP-Solve のライブラリディレクトリ（<span class="monospace">liblpsolve55.*</span>を含むディレクトリです）のパスを
	    環境変数 <span class="code">LIBRARY_PATH</span>，<span class="code">LD_LIBRARY_PATH</span> へ追加してください．<br>
	  </li>
	  <li>
	    <b>Gurobi</b><br>
	    インストール先のパスを環境変数 <span class="code">GUROBI_HOME</span> へ設定してください．<br>
	    また，<span class="code">$GUROBI_HOME/lib</span> を <span class="code">LIBRARY_PATH</span>，<span class="code">LD_LIBRARY_PATH</span> へ，
	    <span class="code">$GUROBI_HOME/include</span> を <span class="code">CPLUS_INCLUDE_PATH</span> へ追加してください．<br>
	  </li>
	</ul>
      </li>      
      <li>
	コンパイルの準備を行います．<br>
	Phillip を展開したディレクトリ上で次のコマンドを実行してください．
	<div class="code">
	  $ python tools/configure.py
	</div>
	いくつかの設定項目の入力を求められた後，Makefile が生成されます．
      </li>
      <li>
	コンパイルします．<br>
	phillip のディレクトリ上で <span class="code">$ make</span> コマンドを実行してください．
      </li>
      <li>
	正常にインストール出来たかをテストします．<br>
	Phillip のディレクトリ上で <span class="code">$ make test</span> コマンドを実行して正常に結果が出力されれば成功です．	
      </li>
    </ol>

    
    <h2>Usage<a href="#Contents" name="Usage">^</a></h2>
    phillp の実行コマンドは以下のとおりです．
    <div class="code">$ bin/phil [options] [inputs]</div>
    入力ファイルが与えられない場合は標準入力を読み取ります．<br>
    使用可能なコマンドオプションについては <a href="#Options">Options</a> を参照してください．

    <p>
      基本的な使い方は次の通りです．
      <ol type="1">
	<li>
	  推論に使用する背景知識，および推論の対象となる観測を用意します．<br>
	  それぞれの形式については <a href="#FileFormat">File format</a> を参照してください．
	</li>
	<li>
	  背景知識をバイナリにコンパイルします．<br>
	  コマンドオプション <span class="code">-m compile_kb</span> を指定して Phillip を実行してください．<br>
	  この時，コンパイルした背景知識の出力先をコマンドオプション <span class="code">-k [PATH]</span> から指定する事が必須となります．
	  以下にコマンドの例を示します．
	  <div class="code">
	    $ bin/phil -m compile_kb -k compiled -p "max_distance=4.0" kb.lisp
	  </div>
	</li>
	<li>
	  推論を実行します．<br>
	  コマンドオプション <span class="code">-m inference</span> を指定して Phillip を実行してください．<br>
	  この時，コマンドオプション <span class="code">-c lhs=[NAME]</span>，
	  <span class="code">-c lhs=[NAME]</span>，<span class="code">-c lhs=[NAME]</span> による各種コンポーネントの指定と，
	  コンパイルした背景知識のパスをコマンドオプション <span class="code">-k [PATH]</span> から指定する事が必須となります．<br>
	  以下にコマンドの例を示します．
	  <div class="code">
	    $ bin/phil -m inference -k compiled -c "lhs=abduction" -c "ilp=weighted" -c "sol=gurobi" -p "max_distance=4.0" obs.lisp
	  </div>
	</li>
      </ol>
    </p>
    <p>
      なお，Phillip の制御はコマンドオプションを介して行われますが，設定内容が多岐に渡るため，実際の使用の際には設定ファイルの利用を推奨しています．<br>
      設定ファイルの書式については <a href="#FileFormat_ConfigureFile">Configure file</a> を参照してください．<br>
      そのほか，テスト用の設定ファイルが <span class="monospace">conf/toy.*.conf</span> にあるので，それらを参考にする事も可能です．
    </p>

    
    <h2>Options<a href="#Contents" name="Options">^</a></h2>
    <h3>Common Options<a href="#Options" name="Options_Common">^</a></h3>
    <ul type="disc">
      <li>
	<span class="code">-m [MODE]</span><br>
	プログラムの実行モードを指定します．<br>
	選べる実行モードは以下の2つです．<br>
	<ul type="circle">
	  <li>
	    <span class="code">-m compile_kb</span><br>
	    入力から与えられた公理をバイナリ形式にコンパイルする等の前処理を行います．<br>
	    推論をする前に必ずこれらを行う必要があります．
	  </li>
	  <li>
	    <span class="code">-m inference</span><br>
	    入力から与えられた観測に対して推論を実行します．
	  </li>
	</ul>
      </li>
      <li>
	<span class="code">-l [PATH]</span><br>
	PATH で指定したファイルを設定ファイルとしてロードします．<br>
	設定ファイルは各行にオプションや入力ファイルが記述されたファイルです．<br>
	設定ファイルの書式については <a href="#FileFormat_ConfigureFile">Configure file</a> を参照してください．
      </li>
      <li>
	<span class="code">-p [NAME]=[VALUE]</span><br>
	パラメタを設定します．<br>
	各コンポーネント固有の制御を行いたい際に用います．
	ユーザ定義したコンポーネント内でコマンドから挙動を制御したい場合にも利用できます．<br>
	デフォルトで使用可能なパラメタは以下の通りです．<br>
	<ul type="circle">
	  <li>
	    <span class="code">-p path_lhs_out=[PATH]</span><br>
	    潜在仮説集合を指定したファイルに出力します．<br>
	    出力はXML形式で提供されます．
	  </li>
	  <li>
	    <span class="code">-p path_ilp_out=[PATH]</span><br>
	    ILPに変換した潜在仮説集合をファイルに出力します．<br>
	    出力はXML形式で提供されます．
	  </li>
	  <li>
	    <span class="code">-p path_sol_out=[PATH]</span><br>
	    変換されたILPの最適解をファイルに出力します．<br>
	    出力はXML形式で提供されます．
	  </li>
	  <li>
	    <span class="code">-p path_out=[PATH]</span><br>
	    最適解の証明木をファイルに出力します．<br>
	    出力はXML形式で提供されます．
	  </li>
	  <li>
	    <span class="code">-p max_distance=[FLOAT]</span><br>
	    Reachable Matrix を生成する際に許容する距離の最大値を指定します．<br>
	    デフォルト値は -1 です．その場合は距離による制限をかけません．
	  </li>
	</ul>
      </li>
      <li>
	<span class="code">-f [NAME]</span><br>
	指定した名称のフラグを立てます．<br>
	各コンポーネント固有の制御を行いたい際に用います．
	ユーザ定義したコンポーネント内でコマンドから挙動を制御したい場合にも利用できます．
      </li>
      <li>
	<span class="code">-v [INT]</span><br>
	処理内容を画面出力する際の詳細さを指定します．<br>
	0 から 5 までの値を指定でき，5 で最も詳細に処理内容を出力します．
      </li>
    </ul>
    
    <h3>Options for compiling<a href="#Options" name="Options_Compile">^</a></h3>
    <ul type="disc">
      <li>
	<span class="code">-k [PATH]</span><br>
	コンパイルした背景知識の出力先を指定します．
      </li>
      <li>
	<span class="code">-c dist=[NAME]</span><br>
	Reachable Matrix を生成する際に，リテラル間の距離を提供するコンポーネントを指定します．<br>
	現在使用可能なコンポーネントは以下の2つです．
	<ul type="circle">
	  <li>
	    <span class="code">-c dist=basic</span><br>
	    リテラル間の距離を全て 1.0 の固定値に設定します．<br>
	    デフォルトではこのコンポーネントが指定されています．
	  </li>
	  <li>
	    <span class="code">-c dist=cost</span><br>
	    リテラル間の距離を，ILP変換コンポーネント <span class="code">-c ilp=costed</span> における公理コストによって与えます．<br>
	    より具体的には，各公理に与えられた推論コスト値をそのまま距離値として採用します．
	  </li>
	</ul>
      </li>
    </ul>
    
    <h3>Options for inference<a href="#Options" name="Options_Inference">^</a></h3>
    <ul type="disc">
      <li>
	<span class="code">-c lhs=[NAME]</span><br>
	観測から潜在仮説集合を生成する際に使用するコンポーネントを指定します．<br>
	推論を行うためには何らかのコンポーネントを指定する必要があります．<br>
	現在使用可能なコンポーネントは以下の3つです．
	<ul type="circle">
	  <li>
	    <span class="code">-c lhs=deduction</span><br>
	    演繹推論に基づいて潜在仮説集合を生成します．<br>
	    観測から演繹的に導かれるものを潜在仮説集合として列挙します．
	  </li>
	  <li>
	    <span class="code">-c lhs=abduction</span><br>
	    仮説推論に基いて潜在仮説集合を生成します．<br>
	    観測に対する説明として仮説できるものを潜在仮説集合として列挙します．
	  </li>
	  <li>
	    <span class="code">-c lhs=bidirection</span><br>
	    演繹推論，仮説推論の両方を利用して潜在仮説集合を生成します．<br>
	    一般に計算量が上の2つよりもかなり大きくなります．
	  </li>
	</ul>
      </li>
      <li>
	<span class="code">-c ilp=[NAME]</span><br>
	潜在仮説集合を整数線形計画問題に変換する際に使用するコンポーネントを指定します．<br>
	推論を行うためには何らかのコンポーネントを指定する必要があります．<br>
	現在使用可能なコンポーネントは以下の3つです．
	<ul type="circle">
	  <li>
	    <span class="code">-c ilp=weighted</span><br>
	    Weighted Abduction をベースにした評価関数に基づいた変換を行います．
	  </li>
	  <li>
	    <span class="code">-c ilp=costed</span><br>
	    コストベースの評価関数に基づいた変換を行います．
	  </li>
	  <li>
	    <span class="code">-c ilp=null</span><br>
	    変換を行いません．<br>
	    出力としては，空の整数線形計画問題が返されます．
	  </li>
	</ul>
      </li>
      <li>
	<span class="code">-c sol=[NAME]</span><br>
	整数線形計画問題の最適解を導出する際に用いるソルバーを指定します．<br>
	推論を行うためには何らかのコンポーネントを指定する必要があります．<br>
	また，それぞれのコンポーネントを使うためには，対応したライブラリを予めインストールし，
	Phillip のコンパイル時にリンクする必要があります．<br>
	現在使用可能なコンポーネントは以下の2つです．
	<ul type="circle">
	  <li>
	    <span class="code">-c sol=lpsolve</span><br>
	    LP-Solve 5.5 を用いて最適解を求めます．	    
	  </li>
	  <li>
	    <span class="code">-c sol=gurobi</span><br>
	    Gurobi-optimizer を用いて最適解を求めます．
	  </li>
	  <li>
	    <span class="code">-c sol=null</span><br>
	    最適解の導出を行いません．
	  </li>
	</ul>
      </li>
      <li>
	<span class="code">-k [PATH]</span><br>
	推論時に用いる背景知識のパスを指定します．<br>
	公理のコンパイル時に指定した <span class="code">-k [PATH]</span> オプションと同じパスを指定すれば問題ありません．
      </li>
      <li>
	<span class="code">-T [INT]</span><br>
	タイムアウト時間を指定します．単位は秒です．
      </li>
    </ul>

    
    <h2>File format<a href="#Contents" name="FileFormat">^</a></h2>
    <h3>Literal<a href="#FileFormat" name="FileFormat_Literal">^</a></h3>
    <div class="indent">
      <p>
	リテラルはLISP形式，即ち <span class="code">(pred x y)</span> のような形式で記述します．<br>
	リテラルにパラメータを設定したい場合は，<span class="code">(pred x y :1.2)</span> のように，
	引数の末尾に <span class="monospace">':'</span> から始まる文字列を与えてください．<br>
	なお，パラメータの扱いは各コンポーネントによって異なります．
      </p>
      <p>
	リテラルの論理積は <span class="code">(^ (pred1 x y) (pred2 x y))</span> のような形式で記述します．<br>
	リテラルと同様に，末尾に <span class="monospace">':'</span> から始まる文字列を与えることで，論理積全体にパラメータを与えることも可能です．
      </p>
    </div>
    
    <h3>Axioms<a href="#FileFormat" name="FileFormat_Axioms">^</a></h3>
    <div class="indent">
      公理は <span class="code">(B (name ax01) (=> (kill e1 x y) (die e2 y)))</span> のような形式で記述されます．<br>
      <span class="monospace">"name"</span> の引数がその公理の名称を表し，
      <span class="monospace">"=>"</span> の第一引数のリテラルが公理の根拠，第二引数のリテラルが公理の帰結に対応します．<br>
      なお，公理の名称については省略可能です．<br>
      また，<span class="code">(B (=> (^ (drink e x y) (liquor y) (adult x)))</span> のように，公理の引数としてリテラルの論理積を用いることも可能です．

      <h4>Axiom Group</h4>
      <div class="indent">
	<p>
	  公理の名称に <span class="monospace">'#'</span> を含めた名前を付けることで，公理にグループを定義することができます．<br>
	  グループ名には <span class="monospace">'#'</span> より前の文字列が用いられ，
	  例えば <span class="code">(B (name grp1#a) (=> ...))</span> のグループ名は <span class="monospace">"grp1"</span> になります．<br>
	  同じグループに属する公理は，同じリテラルに対して同時に適用することが禁止されます．
	</p>
	<p>
	  また，ある公理を複数のグループに属させる場合は，複数の <span class="monospace">'#'</span> を用いることで対応可能です．<br>
	  例えば <span class="code">(B (name grp1#grp2#grp3#a) (=> ...))</span> で表される公理は，<span class="monospace">"grp1"</span>，
	  <span class="monospace">"grp2"</span>，<span class="monospace">"grp3"</span> に属することになります．
	</p>
      </div>
      
      <!-- <h4>Regulate Term's Name</h4> -->
      <!-- <div class="indent"> -->
      <!-- 	<p> -->
      <!-- 	  公理中に現れる変数名として <span class="monospace">'.'</span>，<span class="monospace">'/'</span> を含む文字列を指定する事で， -->
      <!-- 	  仮説されるリテラル中の変数名を規定することができます．<br> -->
      <!-- 	  具体的には，例えば以下のような公理を使って推論を行う場合を考えます． -->
      <!-- 	</p> -->
      <!-- 	<div class="code"> -->
      <!-- 	  (=> (p x) (q x.y))<br> -->
      <!-- 	  (=> (p x) (r x/z)) -->
      <!-- 	</div> -->
      <!-- 	<p> -->
      <!-- 	  これらの公理をリテラル <span class="code">(p A)</span>，<span class="code">(q B)</span>，<span class="code">(r C)</span> に適用すると， -->
      <!-- 	  推論によって作られるリテラルは次のようになります． -->
      <!-- 	</p> -->
      <!-- 	<div class="code"> -->
      <!-- 	  (p A) --deduction-> (q A.y)<br> -->
      <!-- 	  (q B) --abduction-> (p B/y)<br> -->
      <!-- 	  (p A) --deduction-> (r A/z)<br> -->
      <!-- 	  (r C) --abduction-> (p C.z)<br> -->
      <!-- 	</div> -->
      <!-- 	<p> -->
      <!-- 	  以上の例から分かるように <span class="monospace">'.'</span>，<span class="monospace">'/'</span> は互いに逆の操作を表しており， -->
      <!-- 	  例えば <span class="code">(=> (p x) (q x.y))</span> と <span class="code">(=> (p x/y) (q x))</span> は推論上は同じ挙動を示します．<br> -->
      <!-- 	</p> -->
      <!-- 	<p> -->
      <!-- 	  ちなみに，これらの変数名が持つ直感的な意味としては， -->
      <!-- 	  例えば変数 <span class="code">x.y</span> は変数<span class="code">x</span>から操作<span class="code">y</span>によって作られる変数を表し， -->
      <!-- 	  <span class="code">x/y</span> は操作<span class="code">y</span>によって変数<span class="code">x</span>を作るような変数を表していると云えます． -->
      <!-- 	</p> -->
      <!-- </div> -->
    </div>

    <h3>Mutual Exclusiveness<a href="#FileFormat" name="FileFormat_MutualExclusiveness">^</a></h3>
    <div class="indent">
      リテラル間の相互排他性を <span class="code">(B (name xor01) (xor (dog e1 x) (cat e2 x)))</span> のような形式で記述できます．<br>
      これが定義されると，<span class="monospace">"xor"</span> の第一，第二引数のリテラルの間に相互排他性が設定され，
      例えば上の例の場合，第二引数が一致する <span class="monospace">"dog"</span>，<span class="monospace">"cat"</span> が同時に仮説内に存在する事を禁止します．
    </div>
    
    <h3>Observations<a href="#FileFormat" name="FileFormat_Observations">^</a></h3>
    <div class="indent">
      観測は <span class="code">(O (name obs01) (^ (john j) (go j s) (store s)))</span> のような形式で記述します．<br>
      "name" の引数に観測の名称を記述し，"^" の引数に観測されたリテラル群を指定します．<br>
      実装の都合上，観測されるリテラルが一個の場合でも論理積を用いて記述してください．
    </div>

    <h3>Configure File<a href="#FileFormat" name="FileFormat_ConfigureFile">^</a></h3>
    <div class="indent">
      <p>
	設定ファイルは，各行にコマンドオプション又は入力ファイル名が記述されたテキストファイルです．<br>
	作成した設定ファイルを <span class="code">-l PATH</span> オプションで指定することで，
	ファイル内に記述された設定でプログラムを実行することができます．<br>
	例えばコマンド <span class="code">$ bin/phil -m compile_kb -k kb.compiled kb.lisp</span> は，
	設定ファイルを用いて次のようにも実現できます．
      </p>
      <div class="indent">
	<b>compile.conf:</b>
	<div class="code">
	  -m compile_kb<br>
	  -k kb.compiled<br>
	  kb.lisp
	</div>
	<div class="code">$ bin/phil -l compile.conf</div>
      </div>
      <p>
	なお，<span class="monospace">'#'</span> から始まる文はコメントと見做され，読み込み時に無視されます．<br>
	また，設定ファイル内で <span class="code">-l [PATH]</span> オプションを用いて別の設定ファイルを読み込むことも可能です．
      </p>
    </div>

    <h3>File Path<a href="#FileFormat" name="FileFormat_FilePath">^</a></h3>
    <div class="indent">
      <p>
	Phillipでは，ファイルパスを指定するような場合において，以下のマクロが使用可能です．
	<ul type="disc">
	  <li>
	    <span class="code">%TIME</span><br>
	    プログラムの実行時刻に置換されます．<br>
	    例えば出力先のパスを <span class="monospace">"out/%TIME.xml"</span> などと指定した場合，
	    実際の出力先は <span class="monospace">"out/20140428_165830.xml"</span> のようになります．
	  </li>
	</ul>
	また，パス中の <span class="monospace">'/'</span>，<span class="monospace">'\'</span> は実行OSに応じて自動的に置換されます．<br>
	具体的には，Windows上では <span class="monospace">'/'</span> は <span class="monospace">'\'</span> に置換され，
	LinuxおよびMac上では <span class="monospace">'\'</span> は <span class="monospace">'/'</span> に置換されます．
      </p>
      <p>
	なお，以上の変換の対象となるファイルパスとは，より具体的には次の3種類です．
	<ul type="disc">
	  <li>入力ファイルのパス</li>
	  <li>コマンドオプション <span class="code">-l [PATH]</span> におけるパス</li>
	  <li>コマンドオプション <span class="code">-k [PATH]</span> におけるパス</li>
	  <li>
	    コマンドオプション <span class="code">-p [NAME]=[VALUE]</span> において，
	    パラメータ名が <span class="monospace">"path"</span> から始まるものの値
	  </li>
	</ul>
      </p>
    </div>

    
    <h2>Components<a href="#Contents" name="Components">^</a></h2>
    各種コンポーネントの詳細な仕様を以降に記述します．
    
    <h3>LHS-Enumerator<a href="#Components" name="Components_LHSEnumerator">^</a></h3>
    <div class="indent">
      <h4>Deduction</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c lhs=deduction</span> を指定することで利用できます．<br>
	  演繹推論に基いて潜在仮説集合を生成します．
	</p>
	<p>
	  このコンポーネントにおける固有のパラメータおよびフラグは次の通りです．
	  <ul type="circle">
	    <li>
	      <span class="code">-p max_depth=[INT]</span><br>
	      リテラルの深さの最大値を指定します．<br>
	      深さとは，観測リテラルからそのリテラルまでに経た推論の回数を指します．<br>
	      デフォルト値は -1 で，その場合は深さによる制限をかけません．<br>
	      潜在仮説集合の規模は <span class="monospace">max_depth</span> の値に対して指数オーダーで増加するため，
	      適用先における最低限の値を設定することを推奨します．
	    </li>
	    <li>
	      <span class="code">-p max_distance=[FLOAT]</span><br>
	      許容するリテラル間距離の最大値を指定します．<br>
	      ここでの距離は，Reachable Matrix によって定義される距離であることに注意してください．<br>
	      即ち，Reachable Matrix 上での値がここで設定した値を超過するものについては，互いに reachable でないものとして扱われます．<br>
	      なお，Reachable Matrix 生成時にも同名のパラメータを設定しますが，その時に指定した値よりも大きな値をここで設定することはできません．<br>
	      デフォルト値は -1 で，その場合は距離による制限をかけません．
	    </li>
	    <li>
	      <span class="code">-p max_redundancy=[FLOAT]</span><br>
	      許容する冗長度の最大値を指定します．<br>
	      冗長度とは，Reachable Matrix から与えられる最短距離に対して，現在の推論パスがどれだけ遠回りをしているかを表す値です．<br>
	      ここで設定した値を超過する推論パスについては，その時点でそれ以上の推論を行いません．<br>
	      デフォルト値は -1 で，その場合は冗長度による制限をかけません．
	    </li>
	  </ul>
	</p>
      </div>
      <h4>Abduction</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c lhs=abduction</span> を指定することで利用できます．<br>
	  仮説推論に基いて潜在仮説集合を生成します．<br>
	  なお，このコンポーネントにおいて <span class="code">-p [NAME]=[VALUE]</span> から設定可能なパラメータは，Deduction のものと同様です．
	</p>
      </div>
      <h4>Bidirection</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c lhs=bidirection</span> を指定することで利用できます．<br>
	  演繹推論・仮説推論の両方に基いて潜在仮説集合を生成します．<br>
	  なお，このコンポーネントにおいて <span class="code">-p [NAME]=[VALUE]</span> から設定可能なパラメータは，Deduction のものと同様です．
	</p>
      </div>
    </div>
    
    <h3>ILP-Converter<a href="#Components" name="Components_ILPConverter">^</a></h3>
    <div class="indent">
      <h4>Weighted</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c ilp=weighted</span> を指定することで利用できます．<br>
	  Weighted Abduction [Hobbs, 93] をベースにした評価関数に基いてILP変換を行います．
	</p>
	<p>
	  このコンポーネントにおける固有のパラメータおよびフラグは次の通りです．
	  <ul type="circle">
	    <li>
	      <span class="code">-p weight_provider=[FUNCTION]</span><br>
	      推論の重みを与えるためのコンポーネントを指定します．<br>
	      現在使用可能なコンポーネントは次の2つです．<br>
	      なお，デフォルトでは <span class="code">-p weight_provider=basic(1.2)</span> が設定されています．
	      <ul type="circle">
		<li>
		  <span class="code">-p weight_provider=basic([FLOAT])</span><br>
		  基本コンポーネントです．<br>
		  このコンポーネントでは，公理の重みには公理中の各リテラルが持つパラメータ値を採用します．<br>
		  公理中のリテラルに浮動小数値を表すパラメータが設定されていない場合は，重みの合計がデフォルト値になるように重みを均等に割り当てます．<br>
		  ただし，少なくとも一つ浮動小数値を表すパラメータを持つリテラルが存在する場合には，
		  それらのリテラルには各パラメータが表す値を割り当てた上で，その他のリテラルには <span class="monospace">0.0</span> が割り当てられます．<br>
		  例えば以下の例では，1つめの公理を使って逆向き推論を行った時の重みは <span class="monospace">1.5</span>，
		  2つめの公理を使って逆向き推論を行った時の重みはそれぞれ <span class="monospace">{0.6, 0.6}</span>，
		  3つめの公理を使って逆向き推論を行った時の重みはそれぞれ <span class="monospace">{0.0, 1.3}</span> となります
		  （重みのデフォルト値が <span class="monospace">1.2</span> の場合）．
		  <div class="code">
		    (B (=> (p x :1.5) (q x)))<br>
		    (B (=> (^ (p x) (q y)) (r x)))<br>
		    (B (=> (^ (s x) (t y :1.3)) (r x)))
		  </div>
		</li>
	      </ul>
	    </li>
	    <li>
	      <span class="code">-p default_obs_cost=[FLOAT]</span><br>
	      観測コストのデフォルト値を設定します．<br>
	      基本的にはリテラルのパラメータに記述された浮動小数値を観測コストとして扱いますが，
	      浮動小数値をパラメータに含まない観測リテラルについてはここで指定した値がコストとして割り当てられます．<br>
	      例えば，観測 <span class="code">(O (^ (p x :5.0) (q y :abc)))</span> においては，
	      リテラル <span class="code">(p x)</span> に割り当てられるコストは <span class="monospace">$5.0</span> になり，
	      リテラル <span class="code">(q y)</span> に割り当てられるコストはデフォルト値になります．<br>
	      なお，デフォルトでは <span class="code">-p default_obs_cost=10.0</span> が設定されています．
	    </li>
	  </ul>
	</p>
      </div>
      
      <h4>Costed</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c ilp=costed</span> を指定することで利用できます．<br>
	  以降で説明するようなコストによって定義される評価関数に基いてILP変換を行います．
	</p>
	<p>
	  仮説に対する評価関数は以下の様な式によって表現されます．
	  <div class="equation">
	    <img id="eq-costed-0" alt="eq-costed-0">
	  </div>
	  ここで <img id="eq-costed-1" alt="eq-costed-1"> は仮説内で行われた推論の集合，
	  <img id="eq-costed-2" alt="eq-costed-2"> は仮説内で行われたリテラル間の単一化の集合，
	  <img id="eq-costed-3" alt="eq-costed-3"> は仮説内で行われた変数間の単一化の集合を表します．<br>
	  Phillip は，この値が最も小さくなる仮説を最適解として出力します．
	  
	  <script>
	    setTexImage("eq-costed-0",
	    "\\displaystyle Eval(H) = \\sum_{c \\in C^H} cost(c) + \\sum_{u \\in U_{lit}^H} cost(u) + \\sum_{u \\in U_{var}^H} cost(u)");
	    setTexImage("eq-costed-1", "\\displaystyle C^H");
	    setTexImage("eq-costed-2", "\\displaystyle U^H_{lit}");
	    setTexImage("eq-costed-3", "\\displaystyle U^H_{var}");
	  </script>
	</p>
	<p>
	  このコンポーネントにおける固有のパラメータおよびフラグは次の通りです．
	  <ul type="circle">
	    <li>
	      <span class="code">-p cost_provider=[FUNCTION]</span><br>
	      コストの値を与えるためのコンポーネントを指定します．<br>
	      現在使用可能なコンポーネントは次の1つです．<br>
	      なお，デフォルトでは <span class="code">-p cost_provider=basic(10.0, -40.0, 2.0)</span> が設定されています．
	      <ul type="circle">
		<li>
		  <span class="code">-p cost_provider=basic([FLOAT],[FLOAT],[FLOAT])</span><br>
		  最も基本的なコンポーネントです．<br>
		  引数として与えられる浮動小数点数は左から順に，
		  <ol type="1">
		    <li>推論コストのデフォルト値</li>
		    <li>リテラルの単一化に対するコスト</li>
		    <li>変数の単一化に対するコスト</li>
		    </ol>
		  を指定します．<br>
		  このコンポーネントでは，推論コストにはそこで使われている公理が持つパラメータ値を与え，単一化コストには任意の定数値を与えます．<br>
		  推論コストは，まず公理のパラメータ値を参照し，もし浮動小数値を表すパラメータが設定されていなければデフォルト値を用います．<br>
		  例えば以下の例では，前者のコストは 1.2，後者のコストはデフォルト値が割り当てられます．
		  <div class="code">
		    (B (=> (p x) (q x) :1.2))<br>
		    (B (=> (p x) (r x) :abc))
		  </div>
		</li>
	      </ul>
	    </li>
	  </ul>
	</p>
      </div>
    </div>

    <h3>ILP-Solver<a href="#Components" name="Components_ILPSolver">^</a></h3>
    <div class="indent">
      <h4>LpSolve</h4>
      <div class="indent">
	コマンドオプション <span class="code">-c sol=lpsolve</span> を指定することで利用できます．<br>
	LP-Solve 5.5 を利用して整数線形計画問題を最適化します．
      </div>
      <h4>Gurobi</h4>
      <div class="indent">
	<p>
	  コマンドオプション <span class="code">-c sol=gurobi</span> を指定することで利用できます．<br>
	  Gurobi 5.6 を利用して整数線形計画問題を最適化します．
	</p>
	<p>
	  このコンポーネントにおける固有のパラメータおよびフラグは次の通りです．
	  <ul type="circle">
	    <li>
	      <span class="code">-f disable_cpi</span><br>
	      通常では Cutting-Plane-Inference を利用した計算量軽減を図りますが，このフラグが真の場合，これを行いません．
	    </li>
	    <li>
	      <span class="code">-f activate_gurobi_log</span><br>
	      通常では Gurobi のログは出力されませんが，このフラグが真の場合，これを有効にします．<br>
	      なおログ出力は標準出力に対して行われます．
	    </li>
	  </ul>
      </div>
    </div>
	
    <h2>Contact<a href="#Contents" name="Contact">^</a></h2>
    <ul type="disc">
      <li>Name: Kazeto Yamamoto</li>
      <li>E-Mail: kazeto at ecei.tohoku.ac.jp</li>
    </ul>
  </body>
</html>
